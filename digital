<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quine-McCluskey Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: 600;
            color: #495057;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        input[type="number"],
        input[type="text"],
        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .result-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            border: 2px solid #e9ecef;
            display: none;
        }

        .result-section.show {
            display: block;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-title {
            font-size: 1.5em;
            color: #495057;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        .step {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .step h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .step-content {
            color: #495057;
            line-height: 1.8;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .final-result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            font-size: 1.3em;
            font-weight: 600;
            text-align: center;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .help-text {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .implicant {
            display: inline-block;
            background: #e7f3ff;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 5px;
            color: #0066cc;
            font-family: monospace;
            font-size: 1.1em;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #dc3545;
        }

        .group-box {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .group-title {
            font-weight: 600;
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .iteration-box {
            margin: 20px 0;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”§ Quine-McCluskey Calculator</h1>
            <p>Minimize Boolean Functions with Step-by-Step Solutions</p>
        </div>

        <div class="content">
            <div class="input-section">
                <div class="form-group">
                    <label>Number of Variables:</label>
                    <input type="number" id="numVars" min="2" max="6" value="4" placeholder="Enter number of variables (2-6)">
                    <div class="help-text">Specify how many variables in your Boolean function (e.g., 4 for A,B,C,D)</div>
                </div>

                <div class="form-group">
                    <label>Input Type:</label>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="inputType" value="minterm" checked>
                            <span>Minterms (Sum of Products)</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="inputType" value="maxterm">
                            <span>Maxterms (Product of Sums)</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label>Enter Terms:</label>
                    <input type="text" id="terms" placeholder="e.g., 2,3,8,12,13" value="2,3,8,12,13">
                    <div class="help-text">Enter comma-separated decimal numbers</div>
                </div>

                <div class="form-group">
                    <label>Don't Care Terms (Optional):</label>
                    <input type="text" id="dontCares" placeholder="e.g., 10,14" value="10,14">
                    <div class="help-text">Enter don't care conditions if any</div>
                </div>

                <button class="btn" onclick="calculate()">Calculate Minimized Expression</button>
            </div>

            <div id="resultSection" class="result-section">
                <h2 class="result-title">ðŸ“Š Solution</h2>
                <div id="results"></div>
            </div>
        </div>
    </div>

    <script>
        function quineMcCluskey(terms, dontCares, numVars, isMaxterm = false) {
            const minterms = terms;
            
            // 1. Combine terms and Grouping
            const allTerms = [...new Set([...minterms, ...dontCares])].sort((a, b) => a - b);
            let groups = {};
            
            for (const mt of allTerms) {
                const binary = mt.toString(2).padStart(numVars, '0');
                const ones = (binary.match(/1/g) || []).length;
                if (!groups[ones]) groups[ones] = [];
                groups[ones].push(binary);
            }
            
            const initialGroups = JSON.parse(JSON.stringify(groups));
            
            // 2. Find Prime Implicants
            const primeImplicants = new Set();
            const iterations = [JSON.parse(JSON.stringify(groups))];
            
            while (Object.keys(groups).length > 0) {
                const newGroups = {};
                const combined = new Set();
                const keys = Object.keys(groups).map(Number).sort((a, b) => a - b);
                
                for (let i = 0; i < keys.length - 1; i++) {
                    for (const t1 of groups[keys[i]]) {
                        for (const t2 of groups[keys[i + 1]]) {
                            const diffs = [];
                            for (let j = 0; j < numVars; j++) {
                                if (t1[j] !== t2[j]) diffs.push(j);
                            }
                            
                            if (diffs.length === 1) {
                                const pos = diffs[0];
                                const newTerm = t1.substring(0, pos) + '-' + t1.substring(pos + 1);
                                if (!newGroups[keys[i]]) newGroups[keys[i]] = [];
                                newGroups[keys[i]].push(newTerm);
                                combined.add(t1);
                                combined.add(t2);
                            }
                        }
                    }
                }
                
                // Collect uncombined terms as prime implicants
                for (const g of Object.values(groups)) {
                    for (const term of g) {
                        if (!combined.has(term)) {
                            primeImplicants.add(term);
                        }
                    }
                }
                
                // Remove duplicates in new groups
                for (const k in newGroups) {
                    newGroups[k] = [...new Set(newGroups[k])];
                }
                
                if (Object.keys(newGroups).length > 0) {
                    iterations.push(JSON.parse(JSON.stringify(newGroups)));
                }
                
                groups = newGroups;
            }
            
            // 3. PI Chart for Essential Prime Implicants
            const piList = Array.from(primeImplicants);
            const chart = {};
            for (const m of minterms) {
                chart[m] = [];
            }
            
            for (let i = 0; i < piList.length; i++) {
                const pi = piList[i];
                for (const m of minterms) {
                    const mBin = m.toString(2).padStart(numVars, '0');
                    let matches = true;
                    for (let j = 0; j < numVars; j++) {
                        if (pi[j] !== '-' && pi[j] !== mBin[j]) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches) {
                        chart[m].push(i);
                    }
                }
            }
            
            // 4. Identify EPIs
            const episBits = new Set();
            for (const [m, piIndices] of Object.entries(chart)) {
                if (piIndices.length === 1) {
                    episBits.add(piList[piIndices[0]]);
                }
            }
            
            // Helper: Convert binary/dash string to ABC notation
            function toAbc(binaryStr, isPos) {
                const varsLabels = Array.from({length: numVars}, (_, i) => String.fromCharCode(65 + i));
                const parts = [];
                
                for (let i = 0; i < binaryStr.length; i++) {
                    const bit = binaryStr[i];
                    if (bit === '-') continue;
                    
                    if (isPos) {
                        // Maxterm (POS): 0 is normal (A), 1 is primed (A')
                        parts.push(bit === '0' ? varsLabels[i] : varsLabels[i] + "'");
                    } else {
                        // Minterm (SOP): 1 is normal (A), 0 is primed (A')
                        parts.push(bit === '1' ? varsLabels[i] : varsLabels[i] + "'");
                    }
                }
                
                return isPos ? parts.join(" + ") : parts.join("");
            }
            
            // Format output
            const finalPis = Array.from(primeImplicants).map(p => ({
                binary: p,
                expression: toAbc(p, isMaxterm)
            }));
            
            const finalEpis = Array.from(episBits).map(e => ({
                binary: e,
                expression: toAbc(e, isMaxterm)
            }));
            
            return {
                pis: finalPis,
                epis: finalEpis,
                initialGroups,
                iterations,
                chart,
                piList
            };
        }

        function calculate() {
            const numVars = parseInt(document.getElementById('numVars').value);
            const inputType = document.querySelector('input[name="inputType"]:checked').value;
            const termsInput = document.getElementById('terms').value.trim();
            const dontCaresInput = document.getElementById('dontCares').value.trim();

            if (!termsInput) {
                document.getElementById('results').innerHTML = '<div class="error">Please enter at least one term!</div>';
                document.getElementById('resultSection').classList.add('show');
                return;
            }

            let terms = termsInput.split(',').map(t => parseInt(t.trim())).filter(t => !isNaN(t));
            let dontCares = dontCaresInput ? dontCaresInput.split(',').map(t => parseInt(t.trim())).filter(t => !isNaN(t)) : [];

            const isMaxterm = inputType === 'maxterm';
            
            if (isMaxterm) {
                const maxValue = Math.pow(2, numVars);
                const allTerms = Array.from({length: maxValue}, (_, i) => i);
                terms = allTerms.filter(t => !terms.includes(t) && !dontCares.includes(t));
            }

            const result = quineMcCluskey(terms, dontCares, numVars, isMaxterm);
            
            let html = '';

            // Step 1: Binary Representation
            html += '<div class="step"><h3>Step 1: Binary Representation and Initial Grouping</h3><div class="step-content">';
            html += '<table><tr><th>Decimal</th><th>Binary</th><th>Number of 1s</th><th>Type</th></tr>';
            
            const allTerms = [...new Set([...terms, ...dontCares])].sort((a, b) => a - b);
            allTerms.forEach(term => {
                const binary = term.toString(2).padStart(numVars, '0');
                const ones = (binary.match(/1/g) || []).length;
                const type = dontCares.includes(term) ? "Don't Care" : (isMaxterm ? 'Maxterm' : 'Minterm');
                html += `<tr><td>${term}</td><td>${binary}</td><td>${ones}</td><td>${type}</td></tr>`;
            });
            html += '</table>';
            
            html += '<h4 style="margin-top: 20px;">Initial Groups by Number of 1s:</h4>';
            const groupKeys = Object.keys(result.initialGroups).map(Number).sort((a, b) => a - b);
            groupKeys.forEach(key => {
                html += `<div class="group-box"><div class="group-title">Group ${key} (${key} ones)</div>`;
                result.initialGroups[key].forEach(term => {
                    html += `<span class="implicant">${term}</span>`;
                });
                html += '</div>';
            });
            
            html += '</div></div>';

            // Step 2: Combining Process
            html += '<div class="step"><h3>Step 2: Combining Process</h3><div class="step-content">';
            
            result.iterations.forEach((iter, idx) => {
                html += `<div class="iteration-box">`;
                html += `<h4>Column ${idx + 1}</h4>`;
                const keys = Object.keys(iter).map(Number).sort((a, b) => a - b);
                
                keys.forEach(key => {
                    html += `<div class="group-box"><div class="group-title">Group ${key}</div>`;
                    iter[key].forEach(term => {
                        html += `<span class="implicant">${term}</span>`;
                    });
                    html += '</div>';
                });
                html += '</div>';
            });
            
            html += '</div></div>';

            // Step 3: Prime Implicants
            html += '<div class="step"><h3>Step 3: All Prime Implicants</h3><div class="step-content">';
            html += '<p>Prime implicants that cannot be combined further:</p>';
            html += '<table><tr><th>Binary</th><th>Expression</th></tr>';
            result.pis.forEach(pi => {
                html += `<tr><td>${pi.binary}</td><td><strong>${pi.expression}</strong></td></tr>`;
            });
            html += '</table></div></div>';

            // Step 4: Prime Implicant Chart
            html += '<div class="step"><h3>Step 4: Prime Implicant Chart</h3><div class="step-content">';
            html += '<table><tr><th>Prime Implicant</th>';
            terms.forEach(m => html += `<th>${m}</th>`);
            html += '</tr>';
            
            result.pis.forEach(pi => {
                html += `<tr><td>${pi.binary}</td>`;
                terms.forEach(m => {
                    const mBin = m.toString(2).padStart(numVars, '0');
                    let matches = true;
                    for (let j = 0; j < numVars; j++) {
                        if (pi.binary[j] !== '-' && pi.binary[j] !== mBin[j]) {
                            matches = false;
                            break;
                        }
                    }
                    html += `<td style="text-align:center">${matches ? 'âœ“' : ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</table></div></div>';

            // Step 5: Essential Prime Implicants
            html += '<div class="step"><h3>Step 5: Essential Prime Implicants</h3><div class="step-content">';
            if (result.epis.length > 0) {
                html += '<p><strong>Essential Prime Implicants (cover unique minterms):</strong></p>';
                result.epis.forEach(epi => {
                    html += `<span class="implicant">${epi.binary} = ${epi.expression}</span>`;
                });
            } else {
                html += '<p>No essential prime implicants found. All minterms are covered by multiple prime implicants.</p>';
            }
            html += '</div></div>';

            // Step 6: Final Expression
            html += '<div class="step"><h3>Step 6: Minimized Boolean Expression</h3><div class="step-content">';
            
            // Use essential prime implicants for final expression, or all PIs if no EPIs
            const finalTerms = result.epis.length > 0 ? result.epis : result.pis;
            const expression = finalTerms.map(pi => pi.expression).join(isMaxterm ? ' â€¢ ' : ' + ') || '0';
            const formType = isMaxterm ? 'POS (Product of Sums)' : 'SOP (Sum of Products)';
            
            html += `<p><strong>Type:</strong> ${formType}</p>`;
            if (result.epis.length > 0) {
                html += `<p><strong>Using Essential Prime Implicants:</strong></p>`;
            } else {
                html += `<p><strong>Note:</strong> No essential prime implicants. Using all prime implicants for complete coverage.</p>`;
            }
            html += `<div class="final-result">F = ${expression}</div>`;
            html += '</div></div>';

            document.getElementById('results').innerHTML = html;
            document.getElementById('resultSection').classList.add('show');
        }

        document.getElementById('resultSection').classList.remove('show');
    </script>
</body>
</html>
